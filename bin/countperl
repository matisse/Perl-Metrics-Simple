#!/usr/bin/env perl

use strict;
use warnings;
use Carp qw();
use Perl::Metrics::Simple qw(0.13);

my $COMPLEXITY_LEVEL_THRESHOLD = {
    BTW => 10,
    WTF => 20,
    OMG => 30,
};

my $THRESHOLD_TO_CSS_CLASS = {
    0                                  => 'fyi',
    $COMPLEXITY_LEVEL_THRESHOLD->{BTW} => 'btw',
    $COMPLEXITY_LEVEL_THRESHOLD->{WTF} => 'wtf',
    $COMPLEXITY_LEVEL_THRESHOLD->{OMG} => 'omg',
};

my $CSS = {
    body  => ['font-family:sans-serif;'],
    table => [ 'border-collapse:collapse;', 'border-spacing:0px;', 'margin:10px 0px;' ],
    tr       => [ 'text-align:left;',          'vertical-align:top;' ],
    'td, th' => [ 'border:solid 1px #000000;', 'padding:2px;' ],
    th       => ['background-color:#cccccc;'],
    '.fyi'   => ['background-color:#99ff99;'],
    '.btw'   => ['background-color:#ffff99;'],
    '.wtf'   => ['background-color:#ffcc99;'],
    '.omg'   => ['background-color:#ff9999;'],
    '.w300'  => ['width:300px;'],
    '.w200'  => ['width:200px;'],
    '.w100'  => ['width:100px;'],
    '.right' => ['text-align:right;']
};

my $ANALYSIS;
my $HTML_OUTPUT = 0;
my @FILES       = ();

main();

sub main {
    parse_opts();

    set_analysis();

    if ( $HTML_OUTPUT ) {
        print_html();
    }
    else {
        print_plain();
    }
}

sub parse_opts {
    unless ( scalar( @ARGV ) ) {
        print_usage();

        exit;
    }

    foreach ( @ARGV ) {
        if ( $_ eq '--html' ) {
            $HTML_OUTPUT = 1;
        }
        else {
            push( @FILES, $_ );
        }
    }
}

sub print_usage {
    print <<'EOU';
Usage:
    $0 FILE_OR_DIRECTORY [FILE_OR_DIRECTORY ....]
EOU
}

sub set_analysis {
    $ANALYSIS = Perl::Metrics::Simple->new()->analyze_files( @FILES );
}

sub _sort_by_complexity {
    return $b->{mccabe_complexity} <=> $a->{mccabe_complexity};
}

### PLAIN

sub print_plain {
    print 'Perl files found: ' . $ANALYSIS->file_count() . "\n\n";

    print_counts_plain();
    print_subroutine_size_plain();
    print_code_complexity_plain();
    print_list_of_subs_plain();
}

sub print_counts_plain {
    print_headline_plain( 'Counts' );

    print_line_plain( 'total code lines',      $ANALYSIS->lines() );
    print_line_plain( 'lines of non-sub code', $ANALYSIS->main_stats()->{lines} );
    print_line_plain( 'packages found',        $ANALYSIS->package_count() );
    print_line_plain( 'subs/methods',          $ANALYSIS->sub_count() );

    print "\n\n";
}

sub print_line_plain {
    my ( $key, $value ) = @_;

    print $key . ':';
    print ' ' x ( 25 - length( $key ) );
    print $value . "\n";
}

sub print_headline_plain {
    my ( $headline ) = @_;

    print $headline . "\n";
    print '-' x length( $headline );
    print "\n";
}

sub print_subroutine_size_plain {
    print_headline_plain( 'Subroutine/Method Size' );

    print_line_plain( 'min',            $ANALYSIS->summary_stats()->{sub_length}->{min} );
    print_line_plain( 'max',            $ANALYSIS->summary_stats()->{sub_length}->{max} );
    print_line_plain( 'mean',           $ANALYSIS->summary_stats()->{sub_length}->{mean} );
    print_line_plain( 'std. deviation', $ANALYSIS->summary_stats()->{sub_length}->{standard_deviation} );
    print_line_plain( 'median',         $ANALYSIS->summary_stats()->{sub_length}->{median} );

    print "\n\n";
}

sub print_code_complexity_plain {
    print_headline_plain( 'McCabe Complexity' );

    print_complexity_section_plain( 'Code not in any subroutine', 'main_complexity' );
    print "\n";
    print_complexity_section_plain( 'Subroutines/Methods',        'sub_complexity' );

    print "\n\n";
}

sub print_complexity_section_plain {
    my ( $section, $key ) = @_;

    print $section . "\n";

    print_line_plain( 'min',            $ANALYSIS->summary_stats()->{$key}->{min} );
    print_line_plain( 'max',            $ANALYSIS->summary_stats()->{$key}->{max} );
    print_line_plain( 'mean',           $ANALYSIS->summary_stats()->{$key}->{mean} );
    print_line_plain( 'std. deviation', $ANALYSIS->summary_stats()->{$key}->{standard_deviation} );
    print_line_plain( 'median',         $ANALYSIS->summary_stats()->{$key}->{median} );
}

sub print_list_of_subs_plain {
    my @main_from_each_file = map { $_->{main_stats} } @{ $ANALYSIS->file_stats() };
    my @sorted_subs = sort _sort_by_complexity(), ( @{ $ANALYSIS->subs() }, @main_from_each_file );

    my $column_widths = get_column_widths( @main_from_each_file );

    print_headline_plain( 'List of subroutines, with most complex at top' );

    print_column( 'complexity', $column_widths->{mccabe_complexity} );
    print_column( 'sub',        $column_widths->{name} );
    print_column( 'path',       $column_widths->{path} );
    print_column( 'size',       $column_widths->{lines} );
    print "\n";

    foreach my $sub ( @sorted_subs ) {
        print_list_of_subs_line_plain( $sub, $column_widths );
    }

    print "\n\n";
}

sub print_list_of_subs_line_plain {
    my ( $sub, $column_widths ) = @_;

    foreach my $col ( 'mccabe_complexity', 'name', 'path', 'lines' ) {
        print_column( $sub->{$col}, $column_widths->{$col} );
    }

    print "\n";
}

sub print_column {
    my ( $value, $width ) = @_;

    print $value;
    print ' ' x ( $width - length( $value ) + 2 );
}

sub get_column_widths {
    my @main_from_each_file = @_;

    my $column_widths = {
        mccabe_complexity => 10,
        name              => 3,
        path              => 4,
        lines             => 4,
    };

    foreach my $sub ( @main_from_each_file ) {
        foreach my $col ( 'mccabe_complexity', 'name', 'path', 'lines' ) {
            $column_widths->{$col} = length( $sub->{$col} ) if ( length( $sub->{$col} ) > $column_widths->{$col} );
        }
    }

    return $column_widths;
}

### /PLAIN
### HTML

sub print_html {
    print '<!DOCTYPE html><html lang="en">';

    print_head();

    print_body();

    print '</html>';
}

sub print_head {
    print '<head><title>countperl</title><meta charset="utf-8">';

    print_css();

    print '</head>';
}

sub print_css {
    print '<style type="text/css">';

    foreach my $selector ( keys( %$CSS ) ) {
        print $selector . '{';

        foreach ( @{ $CSS->{$selector} } ) {
            print $_;
        }

        print '}';
    }

    print '</style>';
}

sub print_body {
    print '<body><h3>';
    print 'Perl files found ' . $ANALYSIS->file_count();
    print '</h3>';

    print_counts_html();
    print_subroutine_size_html();
    print_code_complexity_html();
    print_list_of_subs_html();
    print_complexity_levels();

    print '</body>';
}

sub print_counts_html {
    print '<table><tr><th colspan="2">Counts</th></tr>';

    print_tr( 'total code lines',      $ANALYSIS->lines() );
    print_tr( 'lines of non-sub code', $ANALYSIS->main_stats()->{lines} );
    print_tr( 'packages found',        $ANALYSIS->package_count() );
    print_tr( 'subs/methods',          $ANALYSIS->sub_count() );

    print '</table>';
}

sub print_tr {
    my ( $key, $value, $css ) = @_;
    $css = $css ? ' ' . $css : '';

    print '<tr><td class="w200">';
    print $key;
    print '</td><td class="w100 right' . $css . '">';
    print $value;
    print '</td></tr>';
}

sub print_subroutine_size_html {
    print '<table><tr><th colspan="2">Subroutine/Method Size</th></tr>';

    print_tr( 'min',            $ANALYSIS->summary_stats()->{sub_length}->{min} );
    print_tr( 'max',            $ANALYSIS->summary_stats()->{sub_length}->{max} );
    print_tr( 'mean',           $ANALYSIS->summary_stats()->{sub_length}->{mean} );
    print_tr( 'std. deviation', $ANALYSIS->summary_stats()->{sub_length}->{standard_deviation} );
    print_tr( 'median',         $ANALYSIS->summary_stats()->{sub_length}->{median} );

    print '</table>';
}

sub print_code_complexity_html {
    print '<table><tr><th colspan="3">McCabe Complexity</th></tr>';

    print_complexity_section_html( 'Code not in any subroutine', 'main_complexity' );
    print_complexity_section_html( 'Subroutines/Methods',        'sub_complexity' );

    print '</table>';
}

sub print_complexity_section_html {
    my ( $section, $key ) = @_;

    print '<tr><td rowspan="5" class="w200">' . $section . '</td>';

    print '<td class="w200">min</td><td class="w100 right ' . get_class_by_count( $ANALYSIS->summary_stats()->{$key}->{min} ) . '">';
    print $ANALYSIS->summary_stats()->{$key}->{min};
    print '</td></tr>';

    print_tr( 'max',  $ANALYSIS->summary_stats()->{$key}->{max},  get_class_by_count( $ANALYSIS->summary_stats()->{$key}->{max} ) );
    print_tr( 'mean', $ANALYSIS->summary_stats()->{$key}->{mean}, get_class_by_count( $ANALYSIS->summary_stats()->{$key}->{mean} ) );
    print_tr(
        'std. deviation',
        $ANALYSIS->summary_stats()->{$key}->{standard_deviation},
        get_class_by_count( $ANALYSIS->summary_stats()->{$key}->{standard_deviation} )
    );
    print_tr( 'median', $ANALYSIS->summary_stats()->{$key}->{median}, get_class_by_count( $ANALYSIS->summary_stats()->{$key}->{median} ) );
}

sub print_list_of_subs_tr {
    my ( $sub ) = @_;

    print '<tr><td class="'
        . get_class_by_count( $sub->{mccabe_complexity} )
        . ' right">'
        . $sub->{mccabe_complexity}
        . '</td><td>'
        . $sub->{name}
        . '</td><td>'
        . $sub->{path}
        . '</td><td class="right">'
        . $sub->{lines}
        . '</td></tr>';
}

sub print_list_of_subs_html {
    my @main_from_each_file = map { $_->{main_stats} } @{ $ANALYSIS->file_stats() };
    my @sorted_subs = sort _sort_by_complexity(), ( @{ $ANALYSIS->subs() }, @main_from_each_file );

    print '<table><tr><th colspan="4">List of subroutines, with most complex at top</th></tr>'
        . '<tr><td class="w100">complexity</td><td>sub</td><td>path</td><td class="w100">size</td><tr>';

    foreach my $sub ( @sorted_subs ) {
        print_list_of_subs_tr( $sub );
    }

    print '</table>';
}

sub print_complexity_levels {
    print '<table><tr><th colspan="2">Complexity Levels</th></tr>';

    foreach my $level ( sort( keys( %$THRESHOLD_TO_CSS_CLASS ) ) ) {
        print '<tr><td class="'
            . $THRESHOLD_TO_CSS_CLASS->{$level} . '">'
            . $THRESHOLD_TO_CSS_CLASS->{$level}
            . '</td><td class="'
            . $THRESHOLD_TO_CSS_CLASS->{$level} . '">'
            . '&gt;= '
            . $level
            . '</td></tr>';
    }

    print '</table>';
}

sub get_class_by_count {
    my ( $count ) = @_;

    my @level = reverse( sort( keys( %$THRESHOLD_TO_CSS_CLASS ) ) );

    foreach ( @level ) {
        return $THRESHOLD_TO_CSS_CLASS->{$_} if ( $count >= $_ );
    }
}

### /HTML

exit;

__END__

=head1 NAME

countperl - count lines, packages, subs and complexity of Perl files.

=head1 SYNOPSIS

B<countperl> F<FILE_OR_DIRECTORY> [F<FILE_OR_DIRECTORY> ....] [--html]

=head1 REQUIRED ARGUMENTS

At least one file or directory path must be supplied.

=head1 EXIT STATUS

Exits zero on success, non-zero on failure.

=head1 DESCRIPTION

F<countperl> uses B<Perl::Metrics::Simple> to examines the named files and
recursivesly searches named directories for Perl files.


Perl files are identified by B<Perl::Metrics::Simple-E<gt>is_perl_file>. Basically
if the file ends in C<.pl>, C<.pm>, or C<.t> or has what appears to be a perl
I<shebang> line.

F<countperl> produces a report on F<STDOUT> of counts of total lines,
packages, subroutines/methods,
the minimum, maximum, mean, standard deviation, and median size and
mccabe_complexity (cyclomatic complexity) of subroutines and
the 'main' portion of each file (everything not in a subroutine.)

=head2 Output Format

Line counts do not include comments nor pod.

The current output format is human-readable text:

    Perl files found:                3

    Counts
    ------
    total code lines:       856
    lines of non-sub code:  450
    packages found:           3
    subs/methods:            42

    Subroutine/Method Size
    ----------------------
    min:                  3 lines
    max:                  32 lines
    mean:                 9.67 lines
    std. deviation:       7.03
    median:               7.50

    McCabe Complexity
    -----------------
    Code not in any subroutine::
    min:                  1
    max                   1
    mean:                 1.00
    std. deviation:       0.00
    median:               1.00

    Subroutines/Methods:
    min:                  1
    max:                  5
    avg:                  1.00
    std. deviation:       1.36
    median:               1.00

    Tab-delimited list of subroutines, with most complex at top
    -----------------------------------------------------------
    complexity      sub     path    size
    5       is_perl_file    lib/Perl/Metrics/Simple.pm      11
    5       _has_perl_shebang       lib/Perl/Metrics/Simple.pm      13
    5       _init   lib/Perl/Metrics/Simple/Analysis/File.pm        30
    4       find_files      lib/Perl/Metrics/Simple.pm      11
    4       new     lib/Perl/Metrics/Simple/Analysis.pm     10
    4       is_ref  lib/Perl/Metrics/Simple/Analysis.pm     8

With --html switch output format is HTML.

=head1 VERSION

This is version 0.031 of F<countperl>.


=head1 BUGS AND LIMITATIONS

=head2 Bugs
No bugs reported yet :-)
See: http://rt.cpan.org/NoAuth/Bugs.html?Dist=Perl-Metrics-Simple

=head2 Limitations

=over 4

=item Does not accept input from STDIN.

=item No machine-readable report format available (e.g. XML, tab-delimited)

=back

=head1 SUPPORT

Via CPAN:

=head2 Disussion Forum

http://www.cpanforum.com/dist/Perl-Metrics-Simple

=head2 Bug Reports

http://rt.cpan.org/NoAuth/Bugs.html?Dist=Perl-Metrics-Simple

=head1 DEPENDENCIES

=over 4

=item L<Perl::Metrics::Simple> 0.13 (which depends upon L<PPI>.)

=item L<Pod::Usage>

=back

=head1 SEE ALSO

=over 4

=item L<PPI>

=item L<Perl::Critic>

=item L<Perl::Metrics>

=item http://en.wikipedia.org/wiki/Cyclomatic_complexity

=back

=head1 AUTHOR

    Matisse Enzer
    CPAN ID: MATISSE
    Eigenstate Consulting, LLC
    matisse@eigenstate.net
    http://www.eigenstate.net/

=head1 LICENSE AND COPYRIGHT

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

The full text of the license can be found in the
LICENSE file included with this module.

=cut
